# scnlib

[![Ubuntu 22 builds](https://github.com/eliaskosunen/scnlib/actions/workflows/ubuntu-22.yml/badge.svg?branch=dev)](https://github.com/eliaskosunen/scnlib/actions/workflows/ubuntu-22.yml)
[![Ubuntu 20 builds](https://github.com/eliaskosunen/scnlib/actions/workflows/ubuntu-20.yml/badge.svg?branch=dev)](https://github.com/eliaskosunen/scnlib/actions/workflows/ubuntu-20.yml)
[![macOS builds](https://github.com/eliaskosunen/scnlib/actions/workflows/macos.yml/badge.svg?branch=dev)](https://github.com/eliaskosunen/scnlib/actions/workflows/macos.yml)
[![Windows builds](https://github.com/eliaskosunen/scnlib/actions/workflows/windows.yml/badge.svg?branch=dev)](https://github.com/eliaskosunen/scnlib/actions/workflows/windows.yml)
[![Alpine builds](https://github.com/eliaskosunen/scnlib/actions/workflows/windows.yml/badge.svg?branch=dev)](https://github.com/eliaskosunen/scnlib/actions/workflows/alpine.yml)
[![Code Coverage](https://codecov.io/gh/eliaskosunen/scnlib/branch/dev/graph/badge.svg?token=LyWrDluna1)](https://codecov.io/gh/eliaskosunen/scnlib)

[![Latest Release](https://img.shields.io/github/v/release/eliaskosunen/scnlib?sort=semver&display_name=tag)](https://github.com/eliaskosunen/scnlib/releases)
[![License](https://img.shields.io/github/license/eliaskosunen/scnlib.svg)](https://github.com/eliaskosunen/scnlib/blob/master/LICENSE)
[![C++ Standard](https://img.shields.io/badge/C%2B%2B-17%2F20%2F23-blue.svg)](https://img.shields.io/badge/C%2B%2B-17%2F20%2F23-blue.svg)

```cpp
#include <scn/scan.h>
#include <print>

int main(void) {
    // Read an integer from stdin
    // with an accompanying message
    auto [result, i] = scn::prompt<int>("What's your favorite number? ", "{}");
    if (result) {
        std::println("Oh, cool, {}!", i);
    }
}

// Example result:
// What's your favorite number? 42
// Oh, cool, 42!
```

## What is this?

`scnlib` is a modern C++ library for replacing `scanf` and `std::istream`.
This library attempts to move use ever so much closer to replacing `iostream`s and C stdio altogether.
It's faster than `iostream` (see Benchmarks), and type-safe, unlike `scanf`.
Think [{fmt}](https://github.com/fmtlib/fmt) or C++20 `std::format`, but in the other direction.

This library is the reference implementation of the ISO C++ standards proposal
[P1729 "Text Parsing"](https://wg21.link/p1729).

This branch (dev) targets v2, and is currently unstable.
For a stable release, see the master branch.

## Documentation

The documentation can be found online, from https://scnlib.readthedocs.io.

To build the docs yourself, build the `scn_doc` and `scn_doc_sphinx` targets generated by CMake.
These targets are generated only if the variable `SCN_DOCS` is set in CMake (done automatically if scnlib is the root project).
The `scn_doc` target requires Doxygen, and the `scn_doc_sphinx` target requires Python 3.8 or better, Sphinx, and Breathe.

## Examples

See more examples in the `examples/` folder.

### Reading a `std::string`

```cpp
#include <scn/scan.h>
#include <print>

int main(void) {
    // Reading a std::string will read until the first whitespace character
    auto [result, word] = scn::scan<std::string>("Hello world", "{}");
    
    if (result) {
        // Will output "Hello":
        std::println("{}", word);
        
        // Will output " world":
        // result.range() is a std::string_view,
        // containing the unparsed input
        std::println("{}", result.range());
    } else {
        std::println("Couldn't parse a word: {}", result.error().msg());
        
        // Will output "Unparsed input: Hello world"
        std::println("Unparsed input: {}", result.range());
    }
}
```

### Reading multiple values

```cpp
#include <scn/scan.h>

int main(void) {
    auto [result, i, j] = scn::scan<int, int>("123 456 foo", "{} {}");
    // result == true
    // result.range() == " foo"
    // i == 123
    // j == 456
    
    auto [result2, str] = scn::scan<std::string>(result.range(), "{}");
    // result2 == true
    // result2.range().empty() == true
    // str == "foo"
}
```

### Reading from a fancier range

```cpp
#include <scn/scan.h>

// scn::ranges is
//  - std::ranges on C++20 or later
//  - nano::ranges on C++17 (bundled implementation)
namespace ranges = scn::ranges;

int main(void) {
    auto [result, i] = scn::scan<int>("123" | ranges::views::reverse, "{}");
    // result == true
    // result.range() is a ranges::reverse_view
    // i == 321
}
```

### Repeated reading

```cpp
#include <scn/scan.h>
#include <vector>

int main(void) {
    std::vector<int> vec{};
    
    // `range` now has the same type,
    // as the range returned from scn::scan,
    // if "123 456 789" was given to it as input
    //
    // By doing this, we can reassign the unparsed leftover range
    // to `range` on every loop iteration
    auto range = scn::scan_map_input_range("123 456 789");
    
    // Structured bindings can't be used in a loop condition
    while (auto tmp = scn::scan<int>(range, "{}")) {
        const auto& [result, i] = tmp;
        vec.push_back(i);
        range = result.range();
    }
}
```

## Features

 * Blazing fast parsing of values (see Benchmarks)
 * Modern C++ interface, featuring
   * type safety (variadic templates, types not determined by the format string)
   * convenience (ranges)
   * ergonomics (values returned from `scn::scan`, no output parameters)
 * `"{python}"`-like format string syntax
   * Including compile-time format string checking
 * Minimal code size increase (in user code, see Benchmarks)
 * Usable without exceptions or RTTI, `<iostream>`s, or even dynamic allocation
   * Configurable through build flags
   * Limited functionality
 * Supports Unicode (input is assumed to be UTF-8, UTF-16, or UTF-32)

## Installing

`scnlib` uses CMake.
If your project already uses CMake, integration should be trivial, through whatever means you like:
`make install` + `find_package`, `FetchContent`, `git submodule` + `add_subdirectory`, or something else.

The `scnlib` CMake target is `scn::scn`

```cmake
# Target with which you'd like to use scnlib
add_executable(my_program ...)
target_link_libraries(my_program scn::scn)
```

See docs for usage without CMake

## Compiler support

TODO

## Benchmarks

### Run-time performance

TODO

### Executable size

Debug

.so size: 24M

| Method         | Executable size | Stripped size |
| :------------- | --------------: | ------------: |
| empty          |            33.1 |          14.6 |
| `std::scanf`   |             570 |          26.9 |
| `std::istream` |             545 |          22.9 |
| `scn::input`   |            1967 |          42.8 |

Release

.so size: 1.1M

| Method         | Executable size | Stripped size |
| :------------- | --------------: | ------------: |
| empty          |            24.1 |          14.6 |
| `std::scanf`   |            25.3 |          14.8 |
| `std::istream` |            26.7 |          14.8 |
| `scn::input`   |            25.7 |          14.8 |

MinSizeRel

.so size: 856K

| Method         | Executable size | Stripped size |
| :------------- | --------------: | ------------: |
| empty          |            24.1 |          14.6 |
| `std::scanf`   |            25.3 |          14.8 |
| `std::istream` |            26.7 |          14.8 |
| `scn::input`   |            27.2 |          14.8 |

### Build time

TODO

## Acknowledgements

The contents of this library are heavily influenced by {fmt} and its derivative works.  
https://github.com/fmtlib/fmt

The design of this library is also inspired by the Python `parse` library:  
https://github.com/r1chardj0n3s/parse

### Third-party libraries

NanoRange for C++17 Ranges implementation:  
https://github.com/tcbrindle/NanoRange

fast_float for floating-point number parsing:  
https://github.com/fastfloat/fast_float

simdutf for Unicode handling:  
https://github.com/simdutf/simdutf

## License

scnlib is licensed under the Apache License, version 2.0.  
Copyright (c) 2017 Elias Kosunen  
See LICENSE for further details.
